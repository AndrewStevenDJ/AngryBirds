import 'dart:math';

import 'package:flame/components.dart';
import 'package:flame/effects.dart';
import 'package:flame/events.dart';
import 'package:flame_forge2d/flame_forge2d.dart';
import 'package:flutter/material.dart';

import 'body_component_with_user_data.dart';
import 'explosion_effect.dart';
import 'shop_menu.dart';

const playerSize = 5.0;

enum PlayerColor {
  pink,
  blue,
  green,
  yellow;

  static PlayerColor get randomColor =>
      PlayerColor.values[Random().nextInt(PlayerColor.values.length)];

  String get fileName =>
      'alien${toString().split('.').last.capitalize}_round.png';
}

class Player extends BodyComponentWithUserData with DragCallbacks, ContactCallbacks {
  Player(Vector2 position, Sprite sprite)
    : _sprite = sprite,
      super(
        renderBody: false,
        bodyDef: BodyDef()
          ..position = position
          ..type = BodyType.static
          ..angularDamping = 0.1
          ..linearDamping = 0.1,
        fixtureDefs: [
          FixtureDef(CircleShape()..radius = playerSize / 2)
            ..restitution = 0.4
            ..density = 0.75
            ..friction = 0.5,
        ],
      );

  final Sprite _sprite;
  PowerUpType? powerUp;
  bool _hasExploded = false;

  @override
  Future<void> onLoad() {
    // Agregar efecto visual del power-up ANTES de cargar
    if (powerUp != null) {
      _addPowerUpVisualEffect();
    }

    addAll([
      CustomPainterComponent(
        painter: _DragPainter(this),
        anchor: Anchor.center,
        size: Vector2(playerSize, playerSize),
        position: Vector2(0, 0),
      ),
      SpriteComponent(
        anchor: Anchor.center,
        sprite: _sprite,
        size: Vector2(playerSize, playerSize),
        position: Vector2(0, 0),
      ),
    ]);
    return super.onLoad();
  }

  @override
  void update(double dt) {
    super.update(dt);

    if (!body.isAwake) {
      removeFromParent();
    }

    if (position.x > camera.visibleWorldRect.right + 10 ||
        position.x < camera.visibleWorldRect.left - 10) {
      removeFromParent();
    }
  }

  @override
  void beginContact(Object other, Contact contact) {
    super.beginContact(other, contact);
    
    if (body.bodyType == BodyType.dynamic && !_hasExploded) {
      // Si es explosivo, explotar al contacto
      if (powerUp == PowerUpType.explosive) {
        _hasExploded = true;
        _explode();
      }
      // Si es splitter, dividirse en 3 al primer contacto
      else if (powerUp == PowerUpType.splitter) {
        _hasExploded = true;
        _split();
      }
      // Si es heavy, hacer un efecto de impacto
      else if (powerUp == PowerUpType.heavy) {
        _heavyImpact();
      }
    }
  }

  void _explode() {
    // Crear efecto visual de explosi√≥n √©pico
    world.add(
      ExplosionEffect(
        position: position.clone(),
        radius: 15.0,
      ),
    );
    
    // Aplicar fuerza a objetos cercanos
    _applyExplosionForce();
    
    // Eliminar el p√°jaro despu√©s de un peque√±o delay
    Future.delayed(const Duration(milliseconds: 50), () {
      if (isMounted) removeFromParent();
    });
  }

  void _applyExplosionForce() {
    final explosionRadius = 15.0;
    final explosionForce = 800.0;
    
    // Buscar todos los cuerpos din√°micos cercanos
    for (final body in world.physicsWorld.bodies) {
      if (body.bodyType != BodyType.dynamic) continue;
      
      final distance = (body.position - this.body.position).length;
      
      if (distance < explosionRadius && distance > 0.1) {
        // Calcular direcci√≥n y fuerza
        final direction = (body.position - this.body.position).normalized();
        final forceMagnitude = explosionForce * (1 - distance / explosionRadius);
        
        // Aplicar impulso
        body.applyLinearImpulse(direction * forceMagnitude);
      }
    }
  }

  void _split() {
    // Crear 3 p√°jaros m√°s peque√±os que salen en diferentes direcciones
    final currentVelocity = body.linearVelocity;
    final angles = [-0.4, 0.0, 0.4]; // √Ångulos de separaci√≥n
    
    for (final angle in angles) {
      final rotation = Matrix2.rotation(angle);
      final newVelocity = rotation.transformed(currentVelocity);
      
      // Crear un mini-p√°jaro
      final miniBird = _MiniPlayer(
        position.clone(),
        _sprite,
        newVelocity,
      );
      
      world.add(miniBird);
    }
    
    // Efecto visual de divisi√≥n
    world.add(
      CircleComponent(
        radius: 3.0,
        paint: Paint()
          ..color = const Color(0xFF2196F3).withOpacity(0.6)
          ..style = PaintingStyle.stroke
          ..strokeWidth = 0.5,
        position: position.clone(),
        anchor: Anchor.center,
      )..add(
          ScaleEffect.to(
            Vector2.all(10),
            EffectController(duration: 0.3),
            onComplete: () => parent?.children
                .whereType<CircleComponent>()
                .firstOrNull
                ?.removeFromParent(),
          ),
        )..add(
          OpacityEffect.fadeOut(
            EffectController(duration: 0.3),
          ),
        ),
    );
    
    removeFromParent();
  }

  void _heavyImpact() {
    // Efecto visual de impacto pesado
    world.add(
      CircleComponent(
        radius: 2.0,
        paint: Paint()
          ..color = const Color(0xFF9C27B0).withOpacity(0.8)
          ..style = PaintingStyle.fill,
        position: position.clone(),
        anchor: Anchor.center,
      )..add(
          ScaleEffect.to(
            Vector2.all(8),
            EffectController(duration: 0.2),
            onComplete: () => parent?.children
                .whereType<CircleComponent>()
                .firstOrNull
                ?.removeFromParent(),
          ),
        )..add(
          OpacityEffect.fadeOut(
            EffectController(duration: 0.2),
          ),
        ),
    );
  }
}

// Mini p√°jaro para el efecto de divisi√≥n
class _MiniPlayer extends BodyComponent {
  _MiniPlayer(Vector2 position, Sprite sprite, Vector2 velocity)
    : _sprite = sprite,
      super(
        renderBody: false,
        bodyDef: BodyDef()
          ..position = position
          ..type = BodyType.dynamic
          ..linearVelocity = velocity * 0.8, // Un poco m√°s lento
        fixtureDefs: [
          FixtureDef(CircleShape()..radius = playerSize / 3)
            ..restitution = 0.4
            ..density = 0.5
            ..friction = 0.5,
        ],
      );

  final Sprite _sprite;

  @override
  Future<void> onLoad() async {
    await super.onLoad();
    
    add(
      SpriteComponent(
        anchor: Anchor.center,
        sprite: _sprite,
        size: Vector2.all(playerSize * 0.6),
        position: Vector2.zero(),
      ),
    );
    
    // Auto-remover despu√©s de 3 segundos
    Future.delayed(const Duration(seconds: 3), () {
      if (isMounted) removeFromParent();
    });
  }

  @override
  void update(double dt) {
    super.update(dt);
    
    // Remover si sale de la pantalla
    if (position.x > camera.visibleWorldRect.right + 10 ||
        position.x < camera.visibleWorldRect.left - 10 ||
        !body.isAwake) {
      removeFromParent();
    }
  }

  Vector2 _dragStart = Vector2.zero();
  Vector2 _dragDelta = Vector2.zero();
  Vector2 get dragDelta => _dragDelta;

  @override
  void onDragStart(DragStartEvent event) {
    super.onDragStart(event);
    if (body.bodyType == BodyType.static) {
      _dragStart = event.localPosition;
    }
  }

  @override
  void onDragUpdate(DragUpdateEvent event) {
    if (body.bodyType == BodyType.static) {
      _dragDelta = event.localEndPosition - _dragStart;
    }
  }

  @override
  void onDragEnd(DragEndEvent event) {
    super.onDragEnd(event);
    if (body.bodyType == BodyType.static) {
      children
          .whereType<CustomPainterComponent>()
          .firstOrNull
          ?.removeFromParent();
      body.setType(BodyType.dynamic);
      
      // Aplicar impulso seg√∫n el power-up
      var impulseMultiplier = 50.0;
      if (powerUp == PowerUpType.heavy) {
        impulseMultiplier = 70.0; // M√°s fuerza con heavy
        body.fixtures.first.density = 1.5; // M√°s denso
      } else if (powerUp == PowerUpType.explosive) {
        impulseMultiplier = 55.0;
      } else if (powerUp == PowerUpType.splitter) {
        impulseMultiplier = 52.0;
      }
      
      body.applyLinearImpulse(_dragDelta * -impulseMultiplier);
      add(RemoveEffect(delay: 5.0));
    }
  }

  void _addPowerUpVisualEffect() {
    Color effectColor;
    String emoji;
    
    switch (powerUp) {
      case PowerUpType.explosive:
        effectColor = const Color(0xFFFF5722);
        emoji = 'üí£';
        break;
      case PowerUpType.heavy:
        effectColor = const Color(0xFF9C27B0);
        emoji = '‚ö°';
        break;
      case PowerUpType.splitter:
        effectColor = const Color(0xFF2196F3);
        emoji = 'üéØ';
        break;
      default:
        return;
    }
    
    // C√≠rculo de aura brillante (m√°s grande y visible)
    add(
      CircleComponent(
        radius: playerSize * 0.8,
        paint: Paint()
          ..color = effectColor.withOpacity(0.3)
          ..style = PaintingStyle.fill,
        anchor: Anchor.center,
        priority: -1, // Detr√°s del sprite
      ),
    );
    
    // Borde pulsante
    final glowRing = CircleComponent(
      radius: playerSize * 0.65,
      paint: Paint()
        ..color = effectColor
        ..style = PaintingStyle.stroke
        ..strokeWidth = 0.4,
      anchor: Anchor.center,
    );
    
    // Efecto de pulsaci√≥n
    glowRing.add(
      ScaleEffect.by(
        Vector2.all(1.3),
        EffectController(
          duration: 0.8,
          alternate: true,
          infinite: true,
        ),
      ),
    );
    
    add(glowRing);
    
    // Emoji indicador encima del p√°jaro
    add(
      TextComponent(
        text: emoji,
        textRenderer: TextPaint(
          style: const TextStyle(
            fontSize: 3.0,
            shadows: [
              Shadow(
                color: Color(0xFF000000),
                offset: Offset(0.2, 0.2),
                blurRadius: 0.5,
              ),
            ],
          ),
        ),
        anchor: Anchor.center,
        position: Vector2(0, -playerSize * 0.8),
      ),
    );
  }
}

extension on String {
  String get capitalize =>
      characters.first.toUpperCase() + characters.skip(1).toLowerCase().join();
}

class _DragPainter extends CustomPainter {
  _DragPainter(this.player);

  final Player player;

  @override
  void paint(Canvas canvas, Size size) {
    if (player.dragDelta != Vector2.zero()) {
      var center = size.center(Offset.zero);
      canvas.drawLine(
        center,
        center + (player.dragDelta * -1).toOffset(),
        Paint()
          ..color = Colors.orange.withAlpha(180)
          ..strokeWidth = 0.4
          ..strokeCap = StrokeCap.round,
      );
    }
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => true;
}